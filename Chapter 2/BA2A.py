# -*- coding: utf-8 -*-
"""BA2A.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fIu7K79912pG4cPxH_p2XPwo19yyE5sr
"""

def HammingDistance(p,q):
    n = len(p)
    c = 0
    for i in range(0,n):
        if p[i] != q[i]:
            c += 1
    return c

def Neighbors(Pattern, d): 
    if d == 0:
       return [Pattern]
    if len(Pattern) == 1:
        return ['A','C','G','T']
    neighborhood = []
    suffixNeighbors = Neighbors(Pattern[1:], d)
    for Text in suffixNeighbors:
        if HammingDistance(Pattern[1:], Text) < d:
            neighborhood.append('A'+Text)
            neighborhood.append('C'+Text)
            neighborhood.append('G'+Text)
            neighborhood.append('T'+Text)
        else:
            neighborhood.append(Pattern[0] + Text)
    return neighborhood

def MotifEnumeration(k,d,Dna):
    possibleMotifs = []
    for i in range(0,len(Dna)):
        all_neighb_in_row = set()
        for j in range (0,len(Dna[i]) - k + 1):
            neighbors = Neighbors(Dna[i][j:j+k],d)
            for neighbor in neighbors:
                all_neighb_in_row.add(neighbor)
        possibleMotifs.append(all_neighb_in_row)
    Motifs = possibleMotifs[0]
    for i in range(1, len(possibleMotifs)):
        Motifs = Motifs.intersection(possibleMotifs[i])
    for motif in Motifs:
      print(motif)

unos="""5 1
GAGATTACACTGTATCCCTGCACGG
CGCTAAGTTACATCTCACGGGACGT
CTCGGCGTTACTTGCACTGTTCGCC
TTAAGTCTGACTCGGAGTGTTGCTC
CCTCTCGCGGGCCGTTGGATCATCG
TATGACTGGACGCGGCAGGCGTGTC
CCCGGGGTAACAATGCCAATCTTGC
AACTTTTACTGGGGCCGCGGAGCGA
TATGATGGTGCTAGAAACCACTCGG
AATGTACCGTGTAGGCAATTCCCGG"""
lines=unos.splitlines()
k=int(lines[0].split(" ")[0])
d=int(lines[0].split(" ")[1])
Dna = []
for i in range(1,len(lines)):
  Dna.append(lines[i])
MotifEnumeration(k,d,Dna)